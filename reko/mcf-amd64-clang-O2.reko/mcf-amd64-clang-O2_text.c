// mcf-amd64-clang-O2_text.c
// Generated by decompiling mcf-amd64-clang-O2
// using Reko decompiler version 0.11.4.0.

#include "mcf-amd64-clang-O2.h"

// 0000000000400940: void _start(Register (ptr64 Eq_8) rdx, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* rdx)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__align_stack<word64>(&ptrArg08);
	__libc_start_main(&g_t400B10, (int32) qwArg00, &ptrArg08, &g_t402DD0, &g_t402E40, rdx, fp);
	__halt();
}

// 0000000000400970: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
	if (true || true)
		return;
	null();
}

// 00000000004009A0: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
	if (true || true)
		return;
	null();
}

// 00000000004009E0: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	if (g_b4050A0 != 0x00)
		return;
	deregister_tm_clones();
	g_b4050A0 = 0x01;
}

// 0000000000400A10: void frame_dummy()
void frame_dummy()
{
	register_tm_clones();
}

// 0000000000400A20: void global_opt()
// Called from:
//      main
void global_opt()
{
	word64 r14_13 = ~0x05;
	do
	{
		printf("active arcs                : %ld\n", g_t407E58);
		primal_net_simplex(&g_t407CB0);
		printf("simplex iterations         : %ld\n", g_t407F08);
		printf("objective value            : %0.0f\n", (real64) flow_cost(&g_t407CB0));
		++r14_13;
		if (r14_13 == 0x00)
		{
l0000000000400AEE:
			printf("checksum                   : %ld\n", g_t407F18);
			return;
		}
		if (g_qw407E68 != 0x00)
		{
			word64 rax_91 = suspend_impl(0x00, ~0x00, 4226224);
			if (rax_91 != 0x00)
				printf("erased arcs                : %ld\n", (int32) rax_91);
		}
		int64 rax_122 = price_out_impl(4226224);
		if (rax_122 == 0x00)
			goto l0000000000400AEE;
		printf("new implicit arcs          : %ld\n", (int32) rax_122);
	} while (rax_122 >= 0x00);
	puts("not enough memory, exit(-1)");
	exit(-1);
}

// 0000000000400B10: void main(Register (ptr64 Eq_141) rsi, Register int32 edi)
void main(struct Eq_141 * rsi, int32 edi)
{
	word64 rdi;
	int32 edi = (word32) rdi;
	if (edi >= 0x02)
	{
		puts("\nMCF SPEC CPU2006 version 1.10");
		puts("Copyright (c) 1998-2000 Zuse Institut Berlin (ZIB)");
		puts("Copyright (c) 2000-2002 Andreas Loebel & ZIB");
		puts("Copyright (c) 2003-2005 Andreas Loebel");
		putchar(0x0A);
		memset(&g_t407CB0, 0, 0x0270);
		g_qw407EC0 = 10000000;
		strcpy(&g_t407CB0, rsi->ptr0008);
		if (read_min(&g_t407CB0) != 0x00)
		{
			puts("read error, exit");
			getfree(&g_t407CB0);
		}
		else
		{
			printf("nodes                      : %ld\n", g_t407E48);
			primal_start_artificial(&g_t407CB0);
			global_opt();
			puts("done");
			write_circulations(4226224, &g_t402F44);
			getfree(&g_t407CB0);
		}
	}
}

// 0000000000400C00: void refresh_neighbour_lists(Register Eq_61 rdi)
// Called from:
//      price_out_impl
//      suspend_impl
//      write_circulations
void refresh_neighbour_lists(Eq_61 rdi)
{
	struct Eq_228 * rax_12;
	struct Eq_228 * rcx_7 = *((word64) rdi + 560);
	for (rax_12 = (word64) *((word64) rdi + 552) + 56; rax_12 < rcx_7; ++rax_12)
		rax_12->ow0000 = 0;
	union Eq_239 * rcx_21 = *((word64) rdi + 568);
	union Eq_239 * r8_22 = *((word64) rdi + 576);
	if (rcx_21 < r8_22)
	{
		up64 rdx_27 = (char *) r8_22 + ~rcx_21;
		if (((byte) rdx_27 & 0x40) == 0x00)
		{
			Eq_265 rsi_32 = *((char *) rcx_21 + 8);
			*((char *) rcx_21 + 32) = rsi_32.ptr0000->ptr0038;
			rsi_32.ptr0000->ptr0038 = rcx_21;
			Eq_278 rsi_36 = *((char *) rcx_21 + 16);
			*((char *) rcx_21 + 40) = rsi_36.ptr0000->ptr0040;
			rsi_36.ptr0000->ptr0040 = rcx_21;
			rcx_21 = (union Eq_239 *) ((char *) rcx_21 + 64);
		}
		if (rdx_27 >= 0x40)
		{
			struct Eq_293 * rcx_46 = (char *) rcx_21 + 64;
			struct Eq_293 * rdx_48 = rcx_46;
			do
			{
				struct Eq_297 * rdi_52 = rcx_121->ptrFFFFFFC8;
				rcx_121->ptrFFFFFFE0 = rdi_52->ptr0038;
				ptr64 rsi_50 = rcx_121 - 64;
				rdi_52->ptr0038 = rsi_50;
				struct Eq_314 * rax_56 = rcx_121->ptrFFFFFFD0;
				rcx_121->ptrFFFFFFE8 = rax_56->ptr0040;
				rax_56->ptr0040 = rsi_50;
				struct Eq_327 * rax_60 = rcx_121->ptr0008;
				rcx_121->ptr0020 = rax_60->ptr0038;
				rax_60->ptr0038 = rcx_121;
				struct Eq_340 * rax_64 = rcx_121->ptr0010;
				rcx_121->ptr0028 = rax_64->ptr0040;
				rax_64->ptr0040 = rcx_121;
				rdx_48 -= ~0x7F;
				rcx_46 = rdx_48;
				rcx_121 = rcx_46;
			} while ((char *) &rcx_121->ptr0028 + 24 < r8_22);
		}
	}
}

// 0000000000400CF0: Register uint64 refresh_potential(Register (ptr64 Eq_108) rdi)
// Called from:
//      primal_net_simplex
uint64 refresh_potential(struct Eq_108 * rdi)
{
	struct Eq_360 * r8_6 = rdi->ptr0228;
	r8_6->qw0000 = ~0x05F5E0FF;
	struct Eq_360 * rdi_14 = r8_6->ptr0010;
	uint64 rax_10 = 0x00;
	if (rdi_14 != r8_6)
	{
		struct Eq_360 * rdx_13 = rdi_14;
		do
		{
			struct Eq_360 * rcx_20;
			for (; rdi_14 != null; rdi_14 = rdi_14->ptr0010)
			{
				word64 rsi_29;
				rdx_13 = rdi_14;
				if (rdi_14->dw0008 == 0x01)
				{
					rcx_20 = rdi_14->ptr0018;
					rsi_29 = rcx_20->qw0000 + *rdi_14->ptr0030;
				}
				else
				{
					rcx_20 = rdi_14->ptr0018;
					rsi_29 = rcx_20->qw0000 - *rdi_14->ptr0030;
					++rax_10;
				}
				rdi_14->qw0000 = rsi_29;
			}
			struct Eq_360 * rsi_46 = rdx_13;
			rdi_14 = rdx_13;
			if (rcx_20 != null)
			{
				do
				{
					rdx_13 = rsi_46->ptr0020;
					rsi_46 = rcx_124;
					rdi_14 = rdx_13;
					if (rdx_13 != null)
						goto l0000000000400D8D;
					rcx_20 = rcx_124->ptr0018;
					rcx_124 = rcx_20;
				} while (rcx_20 != null);
				rdx_13 = null;
				rdi_14 = rcx_124;
			}
l0000000000400D8D:
		} while (rdi_14 != r8_6);
	}
	return rax_10;
}

// 0000000000400DA0: Register word128 flow_cost(Register (ptr64 Eq_121) rdi)
// Called from:
//      global_opt
word128 flow_cost(struct Eq_121 * rdi)
{
	struct Eq_441 * rax_169 = rdi->ptr0238;
	struct Eq_441 * r9_7 = rdi->ptr0240;
	if (rax_169 != r9_7)
	{
		up64 r8_11 = r9_7 - 64 - rax_169;
		uint64 rsi_20 = (uint64) (((word32) r8_11 >> 0x06) + 0x01);
		struct Eq_441 * rdx_118 = rax_169;
		if ((rsi_20 & 0x07) != 0x00)
		{
			ui64 rsi_27 = -(rsi_20 & 0x07);
			rdx_118 = rax_169;
			do
			{
				rdx_118->qw0030 = (uint64) (int8) (rdx_118->dw0018 == 0x02);
				++rdx_118;
				++rsi_27;
			} while (rsi_27 != 0x00);
		}
		if (r8_11 >= 448)
		{
			do
			{
				word32 ecx_63 = rdx_118->dw0058;
				rdx_118->qw0030 = (uint64) (int8) (rdx_118->dw0018 == 0x02);
				rdx_118->qw0070 = (uint64) (int8) (ecx_63 == 0x02);
				rdx_118->qw00B0 = (uint64) (int8) (rdx_118->dw0098 == 0x02);
				rdx_118->qw00F0 = (uint64) (int8) (rdx_118->dw00D8 == 0x02);
				rdx_118->qw0130 = (uint64) (int8) (rdx_118->dw0118 == 0x02);
				rdx_118->qw0170 = (uint64) (int8) (rdx_118->dw0158 == 0x02);
				rdx_118->qw01B0 = (uint64) (int8) (rdx_118->dw0198 == 0x02);
				rdx_118->qw01F0 = (uint64) (int8) (rdx_118->dw01D8 == 0x02);
				rdx_118 += 8;
			} while (r9_7 != rdx_118);
		}
	}
	word64 rdx_128 = rdi->qw0228;
	struct Eq_454 * r8_129 = rdi->ptr0230;
	struct Eq_454 * rdx_130 = rdx_128 + 0x68;
	if (rdx_128 + 0x68 != r8_129)
	{
		do
		{
			rdx_130->ptr0030->qw0030 = rdx_130->qw0050;
			++rdx_130;
		} while (r8_129 != rdx_130);
	}
	uint64 rdx_158;
	uint64 r8_156;
	if (rax_169 != r9_7)
	{
		rdx_158 = 0x00;
		r8_156 = 0x00;
		do
		{
			if (rax_169->qw0030 != 0x00)
			{
				word64 rsi_183;
				int32 ecx_176 = rax_169->ptr0008->dw0060;
				if (ecx_176 >= 0x00)
				{
					rsi_183 = rax_169->qw0000;
					if (ecx_176 != 0x00)
						goto l0000000000400F2D;
					++r8_156;
					rdx_158 = rsi_183 + rdx_158 - rdi->qw0210;
				}
				else if (rax_169->ptr0010->dw0060 <= 0x00)
				{
					rsi_183 = rax_169->qw0000;
l0000000000400F2D:
					rdx_158 += rsi_183;
				}
			}
			++rax_169;
		} while (r9_7 != rax_169);
	}
	else
	{
		r8_156 = 0x00;
		rdx_158 = 0x00;
	}
	return SEQ(0x00, (real64) rdx_158 + (real64) rdi->qw0210 * (real64) r8_156);
}

// 0000000000400F60: void flow_org_cost(Register (ptr64 Eq_655) rdi)
void flow_org_cost(struct Eq_655 * rdi)
{
	struct Eq_656 * rax_169 = rdi->ptr0238;
	struct Eq_656 * r9_7 = rdi->ptr0240;
	if (rax_169 != r9_7)
	{
		up64 r8_11 = r9_7 - 64 - rax_169;
		uint64 rsi_20 = (uint64) (((word32) r8_11 >> 0x06) + 0x01);
		struct Eq_656 * rdx_118 = rax_169;
		if ((rsi_20 & 0x07) != 0x00)
		{
			ui64 rsi_27 = -(rsi_20 & 0x07);
			rdx_118 = rax_169;
			do
			{
				rdx_118->qw0030 = (uint64) (int8) (rdx_118->dw0018 == 0x02);
				++rdx_118;
				++rsi_27;
			} while (rsi_27 != 0x00);
		}
		if (r8_11 >= 448)
		{
			do
			{
				word32 ecx_63 = rdx_118->dw0058;
				rdx_118->qw0030 = (uint64) (int8) (rdx_118->dw0018 == 0x02);
				rdx_118->qw0070 = (uint64) (int8) (ecx_63 == 0x02);
				rdx_118->qw00B0 = (uint64) (int8) (rdx_118->dw0098 == 0x02);
				rdx_118->qw00F0 = (uint64) (int8) (rdx_118->dw00D8 == 0x02);
				rdx_118->qw0130 = (uint64) (int8) (rdx_118->dw0118 == 0x02);
				rdx_118->qw0170 = (uint64) (int8) (rdx_118->dw0158 == 0x02);
				rdx_118->qw01B0 = (uint64) (int8) (rdx_118->dw0198 == 0x02);
				rdx_118->qw01F0 = (uint64) (int8) (rdx_118->dw01D8 == 0x02);
				rdx_118 += 8;
			} while (r9_7 != rdx_118);
		}
	}
	word64 rdx_128 = rdi->qw0228;
	struct Eq_669 * r8_129 = rdi->ptr0230;
	struct Eq_669 * rdx_130 = rdx_128 + 0x68;
	if (rdx_128 + 0x68 != r8_129)
	{
		do
		{
			rdx_130->ptr0030->qw0030 = rdx_130->qw0050;
			++rdx_130;
		} while (r8_129 != rdx_130);
	}
	if (rax_169 != r9_7)
	{
		do
		{
			if (rax_169->qw0030 != 0x00)
			{
				int32 ecx_176 = rax_169->ptr0008->dw0060;
				if (ecx_176 >= 0x00)
				{
					if (ecx_176 == 0x00)
						goto l00000000004010F1;
					goto l00000000004010EE;
				}
				if (rax_169->ptr0010->dw0060 <= 0x00)
				{
l00000000004010EE:
				}
			}
l00000000004010F1:
			++rax_169;
		} while (r9_7 != rax_169);
	}
}

// 0000000000401120: void primal_feasible(Register (ptr64 Eq_108) rdi)
// Called from:
//      primal_net_simplex
void primal_feasible(struct Eq_108 * rdi)
{
	uint64 rbx_121;
	struct Eq_360 * rbx_27 = rdi->ptr0228;
	struct Eq_845 * rbp_28 = rdi->ptr0230;
	struct Eq_845 * rbx_113 = (char *) &rbx_27->ptr0030 + 56;
	if ((char *) &rbx_27->ptr0030 + 56 < rbp_28)
	{
		up64 r12_39 = rdi->qw0248;
		up64 r14_40 = rdi->qw0250;
		do
		{
			up64 rax_43 = rbx_113->qw0030;
			Eq_863 r13_44 = rbx_113->qw0050;
			if (rax_43 >= r12_39 && rax_43 < r14_40)
			{
				Eq_863 rax_84 = -r13_44;
				if (rax_84 < 0x00)
					rax_84 = r13_44;
				if (rax_84 > rdi->t0200)
				{
					printf("PRIMAL NETWORK SIMPLEX: ");
					printf("artificial arc with nonzero flow, node %d (%ld)\n", rbx_113->dw0060, (int32) r13_44);
				}
			}
			else
			{
				Eq_863 rax_54 = rdi->t0200;
				if (r13_44 < -rax_54 || r13_44 - 1 > rax_54)
				{
					printf("PRIMAL NETWORK SIMPLEX: ");
					printf("basis primal infeasible (%ld)\n", (int32) r13_44);
					rbx_121 = 0x00;
					goto l0000000000401208;
				}
			}
			++rbx_113;
		} while (rbx_113 < rbp_28);
		rbx_121 = 0x01;
	}
	else
		rbx_121 = 0x01;
l0000000000401208:
	rdi->qw01E8 = rbx_121;
}

// 0000000000401220: void dual_feasible(Register (ptr64 Eq_108) rdi)
// Called from:
//      primal_net_simplex
void dual_feasible(struct Eq_108 * rdi)
{
	struct Eq_919 * rax_14;
	struct Eq_919 * rcx_9 = rdi->ptr0240;
	for (rax_14 = rdi->ptr0238; rax_14 < rcx_9; ++rax_14)
	{
		Eq_863 rdx_20 = rax_14->qw0000 - *rax_14->ptr0008 + *rax_14->ptr0010;
		if (rax_14->dw0018 < 0x02)
		{
			if (rdx_20 < 0x00 - rdi->t0200)
				goto l000000000040127B;
		}
		else if (rax_14->dw0018 == 0x02 && rdx_20 > rdi->t0200)
		{
l000000000040127B:
			fwrite(&g_v402FBA, 22, 0x01, stderr);
			fwrite(&g_v402FD1, 22, 0x01, stderr);
			return;
		}
	}
}

// 00000000004012C0: void getfree(Register (ptr64 Eq_187) rdi)
// Called from:
//      main
//      read_min
void getfree(struct Eq_187 * rdi)
{
	Eq_985 rdi_9 = rdi->t0228;
	if (rdi_9 != 0x00)
		free(rdi_9);
	Eq_985 rdi_15 = rdi->t0238;
	if (rdi_15 != 0x00)
		free(rdi_15);
	Eq_985 rdi_21 = rdi->t0248;
	if (rdi_21 != 0x00)
		free(rdi_21);
	rdi->t0248.u0 = 0;
	rdi->t0238.u0 = 0;
	rdi->t0228.u0 = 0;
}

// 0000000000401310: Register uint64 read_min(Register (ptr64 Eq_187) rdi)
// Called from:
//      main
uint64 read_min(struct Eq_187 * rdi)
{
	ptr64 fp;
	char bLoc0108;
	Eq_168 qwLoc0130;
	Eq_168 qwLoc0138;
	word64 qwLoc0110;
	FILE * rax_27 = fopen(rdi, "r");
	uint64 r15_130 = ~0x00;
	if (rax_27 == null)
		return r15_130;
	fgets(&bLoc0108, 200, rax_27);
	if (__isoc99_sscanf(&bLoc0108, "%ld %ld", fp - 0x0130, fp - 0x0138) != 0x02)
		return r15_130;
	rdi->t0198 = qwLoc0130;
	rdi->t01B0 = qwLoc0138;
	Eq_168 r12_55 = qwLoc0130 * 0x02 + 0x01;
	rdi->t0190 = r12_55;
	Eq_168 r15_58 = (word64) qwLoc0138.u0 + qwLoc0130 * 0x03;
	rdi->t01A8 = r15_58;
	Eq_168 rbx_62 = 0x01A10000;
	if (qwLoc0130 < 15001)
		rbx_62 = r15_58;
	uint64 rcx_68 = 28900000;
	if (qwLoc0130 < 15001)
		rcx_68 = 3000000;
	rdi->t01A0 = rbx_62;
	rdi->qw01C8 = rcx_68;
	rdi->qw01C0 = rbx_62 - r15_58;
	Eq_985 rax_92 = calloc(qwLoc0130 * 0x02 + 0x02, 0x68);
	rdi->t0228 = rax_92;
	Eq_985 rax_100 = calloc(r12_55, 0x40);
	rdi->t0248 = rax_100;
	Eq_985 rax_106 = calloc(rbx_62, 0x40);
	rdi->t0238 = rax_106;
	Eq_985 rbx_107 = rax_106;
	if (rax_106 == 0x00 || (rax_92 == 0x00 || rax_100 == 0x00))
	{
		puts("read_min(): not enough memory");
		getfree(rdi);
		r15_130 = ~0x00;
		return r15_130;
	}
	Eq_168 r15_146;
	rdi->qw0230 = (word128) rax_92 + r12_55 *s 0x68 + 0x68;
	rdi->t0240.u0 = (word128) rax_106 + (r15_58 << 0x06);
	rdi->ptr0250 = (ptr64) ((word128) rax_100 + (r12_55 << 0x06));
	Eq_168 r8_141 = qwLoc0130;
	if (qwLoc0130 > 0x00)
	{
		struct Eq_1168 * r14_147 = (word128) rax_92 + 0x0068;
		word32 r12d_174 = ~0x00;
		r15_146.u0 = 0x01;
		do
		{
			fgets(&bLoc0108, 200, rax_27);
			word32 r15d_183 = (word32) r15_666;
			if (__isoc99_sscanf(&bLoc0108, "%ld %ld", fp - 0x0130, fp - 0x0138) != 0x02)
				goto l0000000000401715;
			word32 edx_187 = (word32) qwLoc0130;
			word32 ecx_189 = (word32) qwLoc0138;
			if (qwLoc0130 > qwLoc0138)
				goto l0000000000401715;
			r14_147->dw0060 = r12d_174;
			r14_147->qw0050 = ~0x00;
			r8_141 = rdi->t0198;
			word64 rax_181 = r15_666 + r8_141;
			*((word128) rax_92 + (rax_181 * 0x68 + 96)) = r15d_183;
			*((word128) rax_92 + (rax_181 * 0x68 + 80)) = 0x01;
			r14_147->dw0064 = edx_187;
			*((word128) rax_92 + (rax_181 * 0x68 + 100)) = ecx_189;
			int64 rdx_192 = (word128) rax_92 + rdi->t0190 *s 0x68;
			*((word128) rbx_107 + 8) = rdx_192;
			*((word128) rbx_107 + 16) = r14_147;
			Eq_1224 rsi_196 = rdi->t0210;
			*rbx_107 = (word64) rsi_196 + 0x0F;
			*((word128) rbx_107 + 56) = (word64) rsi_196 + 0x0F;
			*((word128) rbx_107 + 32) = *((word128) rax_92 + (rdi->t0190 * 0x68 + 56));
			*((word128) rax_92 + (rdi->t0190 * 0x68 + 56)) = rbx_107;
			*((word128) rbx_107 + 40) = r14_147->qw0040;
			r14_147->qw0040 = (word64) rbx_107;
			ptr64 rdi_203 = (word128) rax_92 + rax_181 *s 0x68;
			*((word128) rbx_107 + 72) = rdi_203;
			*((word128) rbx_107 + 80) = rdx_192;
			*((word128) rbx_107 + 64) = 0x0F;
			*((word128) rbx_107 + 0x0078) = 0x0F;
			*((word128) rbx_107 + 96) = *((word128) rax_92 + (rax_181 * 0x68 + 56));
			Eq_985 rdx_213 = (word128) rbx_107 + 64;
			*((word128) rax_92 + (rax_181 * 0x68 + 56)) = rdx_213;
			*((word128) rbx_107 + 0x0068) = *((word128) rax_92 + (rdi->t0190 * 0x68 + 64));
			*((word128) rax_92 + (rdi->t0190 * 0x68 + 64)) = rdx_213;
			*((word128) rbx_107 + 0x0088) = r14_147;
			*((word128) rbx_107 + 144) = rdi_203;
			Eq_985 rcx_221 = rbx_107 - ~0x7F;
			if (rsi_196 <= 9999999)
				rsi_196.u1 = 10000000;
			ui64 rsi_228 = rsi_196 * 0x02;
			*((word128) rbx_107 + 0x0080) = rsi_228;
			*((word128) rbx_107 + 0x00B8) = rsi_228;
			*((word128) rbx_107 + 0x00A0) = r14_147->qw0038;
			r14_147->qw0038 = (word64) rcx_221;
			*((word128) rbx_107 + 0x00A8) = *((word128) rax_92 + (rax_181 * 0x68 + 64));
			*((word128) rax_92 + (rax_181 * 0x68 + 64)) = rcx_221;
			rbx_107.u0 = (word128) rbx_107 + 0x00C0;
			++r14_147;
			r12d_174 += ~0x00;
			r15_146 = (word64) r15_666 + 1;
			r15_666 = r15_146;
		} while (r15_666 < r8_141);
	}
	else
		r15_146.u0 = 0x01;
	if (r15_146 != (word64) r8_141.u0 + 1)
	{
l0000000000401715:
		r15_130 = ~0x00;
		return r15_130;
	}
	if (rdi->t01B0 > 0x00)
	{
		Eq_168 rbp_266 = 0x00;
		do
		{
			fgets(&bLoc0108, 200, rax_27);
			if (__isoc99_sscanf(&bLoc0108, "%ld %ld %ld", fp - 0x0130, fp - 0x0138, fp - 0x0110) != 0x03)
				goto l0000000000401715;
			word64 rax_294 = Mem292[rdi + 408:word64] + qwLoc0130;
			((word128) rbx_107.u0 + 8)->u0 = (word128) rax_92 + rax_294 *s 0x68;
			((word128) rbx_107.u0 + 16)->u0 = (word128) rax_92 + qwLoc0138 *s 0x68;
			*((word128) rbx_107.u0 + 56) = qwLoc0110;
			*rbx_107.u0 = qwLoc0110;
			*((word128) rbx_107.u0 + 32) = *((word128) rax_92 + (rax_294 * 0x68 + 56));
			*((word128) rax_92 + (rax_294 * 0x68 + 56)) = rbx_107;
			*((word128) rbx_107.u0 + 40) = *((word128) rax_92 + (qwLoc0138 * 0x68 + 64));
			*((word128) rax_92 + (qwLoc0138 * 0x68 + 64)) = rbx_107;
			rbp_266 = (word64) rbp_266 + 1;
			rbx_107.u0 = (word128) rbx_107.u0 + 64;
		} while (rbp_266 < rdi->t01B0);
	}
	if (rdi->t0240 != rbx_107)
	{
		Eq_168 rbx_328;
		rdi->t0240 = rbx_107;
		Eq_985 rax_324 = rdi->t0238;
		if (rax_324 < rbx_107)
			rbx_328 = (rbx_107 + ~rax_324 >>u 0x06) + 0x01;
		else
			rbx_328.u0 = 0x00;
		rdi->t01A8 = rbx_328;
		rdi->t01B0 = rbx_328;
	}
	fclose(rax_27);
	rdi->b00C8 = 0x00;
	Eq_168 rsi_348 = rdi->t0198;
	ui32 esi_362 = (word32) rsi_348;
	if (rsi_348 > 0x00)
	{
		Eq_1224 rdx_351 = rdi->t0210;
		Eq_985 rax_352 = rdi->t0238;
		Eq_1224 rcx_355 = 10000000;
		if (rdx_351 > 9999999)
			rcx_355 = rdx_351;
		uint64 rsi_379;
		ui64 rcx_360 = -(rcx_355 * 0x02);
		uint64 rbp_367 = (uint64) (esi_362 & 0x01);
		if (rsi_348 == 0x01)
		{
			rsi_379 = 0x02;
			if (rbp_367 == 0x00)
				goto l0000000000401818;
			goto l000000000040180B;
		}
		struct Eq_1520 * rdi_374 = (word128) rax_352 + 376;
		uint64 rdx_376 = rbp_367 - rsi_348;
		rsi_379 = 0x02;
		do
		{
			rdi_374->qwFFFFFF08 = rcx_360;
			rdi_374->qwFFFFFF40 = rcx_360;
			rdi_374->qwFFFFFFC8 = rcx_360;
			rdi_374->qw0000 = rcx_360;
			++rdi_374;
			rsi_379 += 0x06;
			rdx_376 += 0x02;
		} while (rdx_376 != 0x00);
		if (rbp_367 != 0x00)
		{
l000000000040180B:
			*((word128) rax_352 + rsi_379 * 0x40) = rcx_360;
			*((word128) rax_352 + (rsi_379 * 0x40 + 56)) = rcx_360;
			goto l0000000000401818;
		}
	}
l0000000000401818:
	r15_130 = 0x00;
	return r15_130;
}

// 0000000000401820: Register uint64 resize_prob(Register Eq_61 rdi)
// Called from:
//      price_out_impl
uint64 resize_prob(Eq_61 rdi)
{
	uint64 rcx_31;
	word64 rax_9 = *((word64) rdi + 456);
	union Eq_239 * rdi_10 = *((word64) rdi + 568);
	int64 rsi_12 = (word64) *((word64) rdi + 416) + rax_9;
	*((word64) rdi + 416) = rsi_12;
	*((word64) rdi + 448) = (word64) *((word64) rdi + 448) + rax_9;
	union Eq_239 * rax_17 = realloc(rdi_10, rsi_12 << 0x06);
	if (rax_17 != null)
	{
		union Eq_239 * rcx_32 = *((word64) rdi + 568);
		*((word64) rdi + 568) = rax_17;
		struct Eq_231 * rdx_35 = *((word64) rdi + 552);
		*((word64) rdi + 576) = (char *) rax_17 + (*((word64) rdi + 424) << 0x06);
		struct Eq_228 * rsi_39 = *((word64) rdi + 560);
		struct Eq_228 * rdi_40 = (char *) &rdx_35->a0038->ptr0000 + 48;
		if ((char *) &rdx_35->a0038->ptr0000 + 48 < rsi_39)
		{
			ptr64 rax_48 = rax_17 - rcx_32;
			rcx_31 = 0x00;
			do
			{
				if (rdi_40->qw0018 != rdx_35)
					rdi_40->qw0030 += rax_48;
				++rdi_40;
			} while (rdi_40 < rsi_39);
		}
		else
			rcx_31 = 0x00;
	}
	else
	{
		printf("network %s: not enough memory\n", rdi);
		fflush(stdout);
		rcx_31 = ~0x00;
	}
	return rcx_31;
}

// 00000000004018E0: void insert_new_arc(Register word64 rcx, Register word64 rdx, Register int64 rsi, Register (arr Eq_4006) rdi, Register Eq_1657 r8, Register int64 r9)
void insert_new_arc(word64 rcx, word64 rdx, int64 rsi, Eq_4006 rdi[], Eq_1657 r8, int64 r9)
{
	rdi[rsi].qw0008 = rdx;
	rdi[rsi].qw0010 = rcx;
	rdi[rsi].t0038 = r8;
	rdi[rsi].t0000 = r8;
	rdi[rsi].qw0030 = r9;
	if (rsi != 0x00)
	{
		Eq_1684 r11_29 = rsi + 1;
		do
		{
			Eq_1742 r11_33 = (word64) r11_29 + (r11_29 >> 0x3F);
			int64 r10_35 = (r11_33 >> 0x01) - 1;
			r11_29 = r11_33 >> 0x01;
			int64 r15_40 = rdi[r10_35].qw0030;
			if (r15_40 >= r9)
				return;
			rdi[rsi].qw0010 = rdi[r10_35].qw0010;
			rdi[rsi].t0000 = rdi[r10_35].t0000;
			rdi[rsi].t0038 = rdi[r10_35].t0000;
			rdi[rsi].qw0030 = r15_40;
			rdi[r10_35].qw0008 = rdx;
			rdi[r10_35].qw0010 = rcx;
			rdi[r10_35].t0000 = r8;
			rdi[r10_35].t0038 = r8;
			*((char *) &(rdi + (r10_35 << 0x06) /64 64)->t0000 + 48) = r9;
			rsi = (r11_33 >> 0x01) - 1;
		} while (r11_33 >> 0x01 != 1);
	}
}

// 0000000000401990: void replace_weaker_arc(Register Eq_1761 rcx, Register Eq_1762 rdx, Register (ptr64 Eq_1763) rsi, Register (ptr64 Eq_1764) rdi, Register Eq_1765 r8, Register Eq_1766 r9)
void replace_weaker_arc(Eq_1761 rcx, Eq_1762 rdx, struct Eq_1763 * rsi, struct Eq_1764 * rdi, Eq_1765 r8, Eq_1766 r9)
{
	*((char *) &rsi->a0000[0] + 8) = (struct Eq_1763 *) rdx;
	*((char *) &rsi->a0000[0] + 16) = (struct Eq_1763 *) rcx;
	rsi->a0000[0].qw0038 = (word64) r8;
	rsi->a0000[0] = r8;
	*((char *) &rsi->a0000[0] + 48) = (struct Eq_1763 *) r9;
	Eq_1782 r11_33 = 0x03 - (uint64) ((int8) (rsi->qw0070 > rsi->qw00B0));
	Eq_1782 r10_35 = rdi->t01C0;
	if (r11_33 <= r10_35)
	{
		Eq_1782 rdi_39 = 0x01;
		do
		{
			Eq_1803 rax_42 = r11_33 - 1;
			Eq_1766 r11_46 = *((char *) &rsi->a0000[rax_42] + 48);
			if (r11_46 <= r9)
				return;
			(rsi - 48)[rdi_39].qw0000 = *((char *) &rsi->a0000[rax_42] + 16);
			(rsi - 64)[rdi_39].ow0000 = (word128) rsi[rax_42 * 0x40 /64 0x00B8];
			(rsi - 8)[rdi_39].qw0000 = (word64) rsi[rax_42 * 0x40 /64 0x00B8];
			(rsi - 16)[rdi_39] = r11_46;
			*((char *) &rsi->a0000[rax_42] + 8) = (struct Eq_1763 *) rdx;
			*((char *) &rsi->a0000[rax_42] + 16) = (struct Eq_1763 *) rcx;
			rsi[rax_42 * 0x40 /64 0x00B8] = (struct Eq_1763) r8;
			rsi->a0000[rax_42].qw0038 = (word64) r8;
			*((char *) &rsi->a0000[rax_42] + 48) = (struct Eq_1763 *) r9;
			ui64 rax_69 = r11_33 * 0x02;
			r11_33 *= 0x02;
			Eq_1782 rax_70 = rax_69 + 0x01;
			if (rax_69 + 0x01 <= r10_35)
			{
				if ((rsi - 16)[r11_33].qw0000 >= *((char *) (&(rsi->a0000)[r11_33]) + 48))
					rax_70 = r11_33;
				r11_33 = rax_70;
			}
			rdi_39 = r11_33;
		} while (r11_33 <= r10_35);
	}
}

// 0000000000401A80: Register Eq_1580 price_out_impl(Register Eq_61 rdi)
// Called from:
//      global_opt
Eq_1580 price_out_impl(Eq_61 rdi)
{
	Eq_1580 rax_143;
	union Eq_239 * r11_31;
	Eq_1890 r14_101;
	union Eq_239 * r10_109;
	uint64 rax_123;
	Eq_1890 r8_148 = *((word64) rdi + 408);
	word64 rbx_25 = *((word64) rdi + 528);
	if (r8_148 < 15001)
	{
		ui64 rcx_38 = *((word64) rdi + 424);
		int64 rax_37 = *((word64) rdi + 416);
		if ((word64) *((word64) rdi + 456) + rcx_38 > rax_37 && rcx_38 + (r8_148 *s r8_148 >> 0x01) > rax_37)
		{
			rax_143.u0 = ~0x00;
			if (resize_prob(rdi) != 0x00)
				return rax_143;
			refresh_neighbour_lists(rdi);
			r8_148 = *((word64) rdi + 408);
			rax_123 = 0x01;
		}
		else
			rax_123 = 0x00;
		r10_109 = (union Eq_239 *) *((word64) rdi + 568);
		r11_31 = (union Eq_239 *) *((word64) rdi + 576);
		if (r8_148 <= 0x00)
		{
			r14_101.u1 = 0x00;
			if (r8_148 <= 0x00)
				goto l0000000000401FA5;
			goto l0000000000401B80;
		}
	}
	else
	{
		r10_109 = (union Eq_239 *) *((word64) rdi + 568);
		r11_31 = (union Eq_239 *) *((word64) rdi + 576);
		rax_123 = 0x00;
	}
	r14_101.u1 = 0x00;
	while (*((char *) r10_109 + 88) == ~0x00)
	{
		r14_101 = (word64) r14_101.u1 + 1;
		r10_109 = (union Eq_239 *) ((char *) r10_109 + 0x00C0);
		if (r14_101 >= r8_148)
			break;
	}
	if (r14_101 >= r8_148)
	{
l0000000000401FA5:
		rax_143.u1 = 0x00;
		return rax_143;
	}
l0000000000401B80:
	Eq_61 rdi_150 = rdi;
	word64 rbx_139 = rbx_25 + ~0x0E;
	struct Eq_1970 * rsi_141 = null;
	rax_143.u1 = 0x00;
	r8_248 = r8_148;
	do
	{
		Eq_1890 r8_248;
		if (*((char *) r10_109 + 88) != ~0x00)
		{
			*((char *) *((char *) *((char *) *((char *) r10_109 + 16) + 56) + 16) + 72) = (union Eq_239 *) rsi_141;
			rsi_141 = (struct Eq_1970 *) ((char *) r10_109 + 64);
		}
		if (*((char *) r10_109 + 24) != ~0x00)
		{
			struct Eq_1998 * rbp_172 = rsi_141->ptr0008->ptr0048;
			if (rbp_172 != null)
			{
				Eq_2007 r12_176 = *((char *) r10_109 + 16);
				int64 r15_182 = rbx_139 - *((char *) r10_109 + 56) + (int64) (*((word64) r12_176 + 100));
				do
				{
					Eq_2021 rdx_186 = rbp_172->t0008;
					if ((int64) *((word64) rdx_186 + 100) + rbp_172->qw0038 <= r15_182)
					{
						Eq_2180 r13_196 = (word64) *r12_176 + (0x1E - *rdx_186);
						if (r13_196 < 0x00)
						{
							Eq_1580 rbp_200 = *((word64) rdi_150 + 448);
							if (rax_143 < rbp_200)
							{
								*((char *) r11_31 + (rax_143 * 0x40 + 8)) = (union Eq_239 *) rdx_186;
								*((char *) r11_31 + (rax_143 * 0x40 + 16)) = (union Eq_239 *) r12_176;
								*((char *) r11_31 + (rax_143 * 0x40 + 56)) = 0x1E;
								*((char *) r11_31 + rax_143 * 0x40) = 0x1E;
								*((char *) r11_31 + (rax_143 * 0x40 + 48)) = (union Eq_239 *) r13_196;
								if (rax_143 != 0x00)
								{
									Eq_1580 r8_315 = (word64) rax_143.u1 + 1;
									Eq_1580 rbp_316 = r8_315;
									do
									{
										word64 rbp_320 = rbp_316 + (rbp_316 >>u 0x3F);
										int64 rsi_322 = (rbp_320 >> 0x01) - 1;
										rbp_316 = rbp_320 >> 0x01;
										Eq_2180 rcx_327 = *((char *) r11_31 + (rsi_322 * 0x40 + 48));
										if (rcx_327 >= r13_196)
											break;
										*((char *) r11_31 + (rax_143 * 0x40 + 16)) = *((char *) r11_31 + (rsi_322 * 0x40 + 16));
										*((char *) r11_31 + rax_143 * 0x40) = *((char *) r11_31 + rsi_322 * 0x40);
										*((char *) r11_31 + (rax_143 * 0x40 + 56)) = *((char *) r11_31 + rsi_322 * 0x40);
										*((char *) r11_31 + (rax_143 * 0x40 + 48)) = (union Eq_239 *) rcx_327;
										*((char *) r11_31 + (rsi_322 * 0x40 + 8)) = (union Eq_239 *) rdx_186;
										*((char *) r11_31 + (rsi_322 * 0x40 + 16)) = (union Eq_239 *) r12_176;
										*((char *) r11_31 + rsi_322 * 0x40) = 0x1E;
										*((char *) r11_31 + (rsi_322 * 0x40 + 56)) = 0x1E;
										*((char *) r11_31 + (rsi_322 * 0x40 + 48)) = (union Eq_239 *) r13_196;
										rax_143 = (rbp_320 >> 0x01) - 1;
									} while (rbp_320 >> 0x01 != 1);
									rax_143 = r8_315;
									rdi_150 = rdi;
									rbx_139 = rbx_25 + ~0x0E;
									r8_248 = r8_148;
								}
								else
									rax_143.u1 = 0x01;
							}
							else if (*((char *) r11_31 + 48) > r13_196)
							{
								*((char *) r11_31 + 8) = (union Eq_239 *) rdx_186;
								*((char *) r11_31 + 16) = (union Eq_239 *) r12_176;
								*((char *) r11_31 + 56) = 0x1E;
								*r11_31 = 0x1E;
								*((char *) r11_31 + 48) = (union Eq_239 *) r13_196;
								Eq_1580 r9_225 = 0x03 - (uint64) ((int8) (*((char *) r11_31 + 112) > *((char *) r11_31 + 0x00B0)));
								if (r9_225 <= rbp_200)
								{
									Eq_1580 rdi_229 = 0x01;
									do
									{
										Eq_2387 rbp_237 = r9_225 - 1;
										Eq_2180 rcx_241 = *((char *) r11_31 + (rbp_237 * 0x40 + 48));
										if (rcx_241 <= r13_196)
										{
											rdi_150 = rdi;
											r8_248 = r8_148;
											rbx_139 = rbx_25 + ~0x0E;
											goto l0000000000401E55;
										}
										(r11_31 - 48)[rdi_229].qw0000 = *((char *) r11_31 + (rbp_237 * 0x40 + 16));
										(r11_31 - 64)[rdi_229].t0000 = *((char *) r11_31 + rbp_237 * 0x40);
										(r11_31 - 8)[rdi_229].t0000 = *((char *) r11_31 + rbp_237 * 0x40);
										(r11_31 - 16)[rdi_229].t0000 = rcx_241;
										*((char *) r11_31 + (rbp_237 * 0x40 + 8)) = (union Eq_239 *) rdx_186;
										*((char *) r11_31 + (rbp_237 * 0x40 + 16)) = (union Eq_239 *) r12_176;
										*((char *) r11_31 + rbp_237 * 0x40) = 0x1E;
										*((char *) r11_31 + (rbp_237 * 0x40 + 56)) = 0x1E;
										((char *) r11_31 + (rbp_237 << 0x06))[48] = (char) r13_196;
										ui64 rcx_269 = r9_225 * 0x02;
										r9_225 *= 0x02;
										Eq_1580 rcx_270 = rcx_269 + 0x01;
										if (rcx_269 + 0x01 <= rbp_200)
										{
											if ((r11_31 - 16)[r9_225].qw0000 >= *((char *) r11_31 + (r9_225 * 0x40 + 48)))
												rcx_270 = r9_225;
											r9_225 = rcx_270;
										}
										rdi_229 = r9_225;
									} while (r9_225 <= rbp_200);
									rdi_150 = rdi;
									rbx_139 = rbx_25 + ~0x0E;
									r8_248 = r8_148;
								}
							}
						}
					}
l0000000000401E55:
					rbp_172 = (struct Eq_1998 *) *((word64) rdx_186 + 72);
				} while (rbp_172 != null);
			}
		}
		r14_101 = (word64) r14_101 + 1;
		r10_109 = (union Eq_239 *) ((char *) r10_109 + 0x00C0);
	} while (r14_101 != r8_248);
	if (rax_143 != 0x00)
	{
		uint64 rsi_414 = rax_143 << 0x06;
		union Eq_239 * rdx_426 = (char *) r11_31 + rsi_414;
		*((word64) rdi + 576) = rdx_426;
		byte sil_437 = (byte) rsi_414 + 0xC0;
		uint32 esi_483 = (word32) rsi_414 + ~0x3F;
		if (rax_123 != 0x00)
		{
			uint64 rcx_491 = (uint64) ((esi_483 >> 0x06) + 0x01);
			if ((rcx_491 & 0x07) != 0x00)
			{
				ui64 rcx_497 = -(rcx_491 & 0x07);
				do
				{
					*((char *) r11_31 + 48) = 0x00;
					*((char *) r11_31 + 24) = (union Eq_239 *) 0x01;
					r11_31 = (union Eq_239 *) ((char *) r11_31 + 64);
					++rcx_497;
				} while (rcx_497 != 0x00);
			}
			if (rsi_414 >= 0x0200)
			{
				do
				{
					*((char *) r11_31 + 48) = 0x00;
					*((char *) r11_31 + 24) = (union Eq_239 *) 0x01;
					*((char *) r11_31 + 112) = 0x00;
					*((char *) r11_31 + 88) = (union Eq_239 *) 0x01;
					*((char *) r11_31 + 0x00B0) = 0x00;
					*((char *) r11_31 + 0x0098) = (union Eq_239 *) 0x01;
					*((char *) r11_31 + 0x00F0) = 0x00;
					*((char *) r11_31 + 0x00D8) = (union Eq_239 *) 0x01;
					*((char *) r11_31 + 304) = 0x00;
					*((char *) r11_31 + 0x0118) = (union Eq_239 *) 0x01;
					*((char *) r11_31 + 368) = 0x00;
					*((char *) r11_31 + 344) = (union Eq_239 *) 0x01;
					*((char *) r11_31 + 432) = 0x00;
					*((char *) r11_31 + 408) = (union Eq_239 *) 0x01;
					*((char *) r11_31 + 496) = 0x00;
					*((char *) r11_31 + 472) = (union Eq_239 *) 0x01;
					r11_31 = (union Eq_239 *) ((char *) r11_31 + 0x0200);
				} while (rdx_426 != r11_31);
			}
		}
		else
		{
			if ((sil_437 & 0x40) == 0x00)
			{
				*((char *) r11_31 + 48) = 0x00;
				*((char *) r11_31 + 24) = (union Eq_239 *) 0x01;
				Eq_2356 rcx_443 = *((char *) r11_31 + 8);
				*((char *) r11_31 + 32) = (union Eq_239 *) *((word64) rcx_443 + 56);
				*((word64) rcx_443 + 56) = r11_31;
				Eq_2369 rcx_447 = *((char *) r11_31 + 16);
				*((char *) r11_31 + 40) = (union Eq_239 *) *((word64) rcx_447 + 64);
				*((word64) rcx_447 + 64) = r11_31;
				r11_31 = (union Eq_239 *) ((char *) r11_31 + 64);
			}
			if (rsi_414 != ~0x3F)
			{
				do
				{
					*((char *) r11_31 + 48) = 0x00;
					*((char *) r11_31 + 24) = (union Eq_239 *) 0x01;
					Eq_2474 rcx_460 = *((char *) r11_31 + 8);
					*((char *) r11_31 + 32) = (union Eq_239 *) *((word64) rcx_460 + 56);
					*((word64) rcx_460 + 56) = r11_31;
					Eq_2487 rcx_464 = *((char *) r11_31 + 16);
					*((char *) r11_31 + 40) = (union Eq_239 *) *((word64) rcx_464 + 64);
					*((word64) rcx_464 + 64) = r11_31;
					*((char *) r11_31 + 112) = 0x00;
					*((char *) r11_31 + 88) = (union Eq_239 *) 0x01;
					struct Eq_2508 * rsi_471 = *((char *) r11_31 + 72);
					*((char *) r11_31 + 96) = rsi_471->ptr0038;
					ptr64 rcx_468 = (char *) r11_31 + 64;
					rsi_471->ptr0038 = rcx_468;
					struct Eq_2524 * rsi_475 = *((char *) r11_31 + 80);
					*((char *) r11_31 + 0x0068) = rsi_475->ptr0040;
					rsi_475->ptr0040 = rcx_468;
					r11_31 -= ~0x7F;
				} while (rdx_426 != r11_31);
			}
		}
		Mem552[rdi_150 + 424:word64] = Mem542[rdi_150 + 424:word64] + rax_143;
		Mem554[rdi_150 + 440:word64] = Mem552[rdi_150 + 440:word64] + rax_143;
		*((word64) rdi_150 + 448) -= rax_143;
		return rax_143;
	}
	goto l0000000000401FA5;
}

// 0000000000402090: Register uint64 suspend_impl(Register uint64 rdx, Register int64 rsi, Register Eq_61 rdi)
// Called from:
//      global_opt
uint64 suspend_impl(uint64 rdx, int64 rsi, Eq_61 rdi)
{
	uint64 r14_101;
	if (rdx != 0x00)
	{
		r14_101 = (uint64) *((word64) rdi + 440);
		if (r14_101 == 0x00)
			goto l0000000000402181;
	}
	else
	{
		union Eq_239 * r8_19 = *((word64) rdi + 576);
		union Eq_239 * rax_22 = (word64) *((word64) rdi + 568) + (*((word64) rdi + 424) - *((word64) rdi + 440) << 0x06);
		r14_101 = 0x00;
		if (rax_22 >= r8_19)
			return r14_101;
		union Eq_239 * rdx_161 = rax_22;
		do
		{
			word32 ebx_33 = *((char *) rax_22 + 24);
			int64 rcx_32 = ~0x01;
			if (ebx_33 != 0x00)
			{
				if (ebx_33 == 0x01)
					rcx_32 = (char *) **((char *) rax_22 + 16) + (*rax_22 - *(*((char *) rax_22 + 8)));
				if (rcx_32 > rsi)
					goto l0000000000402109;
				goto l0000000000402127;
			}
			struct Eq_2612 * rbx_37 = *((char *) rax_22 + 8);
			if (rax_22 != rbx_37->ptr0030)
				rbx_37 = (struct Eq_2612 *) *((char *) rax_22 + 16);
			rbx_37->ptr0030 = rdx_161;
			if (rsi >= ~0x01)
			{
l0000000000402127:
				Eq_2642 xmm0_67 = *rax_22;
				Eq_2646 xmm1_68 = *((char *) rax_22 + 16);
				word128 xmm2_69 = *((char *) rax_22 + 32);
				*((char *) rdx_161 + 48) = *((char *) rax_22 + 48);
				*((char *) rdx_161 + 32) = (union Eq_239 *) xmm2_69;
				*((char *) rdx_161 + 16) = (union Eq_239 *) xmm1_68;
				*rdx_161 = (union Eq_239 *) xmm0_67;
				rdx_161 = (union Eq_239 *) ((char *) rdx_161 + 64);
			}
			else
			{
l0000000000402109:
				++r14_101;
			}
			rax_22 = (union Eq_239 *) ((char *) rax_22 + 64);
		} while (rax_22 < r8_19);
		if (r14_101 == 0x00)
		{
l0000000000402181:
			r14_101 = 0x00;
			return r14_101;
		}
	}
	*((word64) rdi + 424) -= r14_101;
	*((word64) rdi + 440) -= r14_101;
	*((word64) rdi + 576) -= r14_101 << 0x06;
	*((word64) rdi + 448) = (word64) *((word64) rdi + 448) + r14_101;
	refresh_neighbour_lists(rdi);
	return r14_101;
}

// 0000000000402190: void primal_start_artificial(Register (ptr64 Eq_200) rdi)
// Called from:
//      main
void primal_start_artificial(struct Eq_200 * rdi)
{
	struct Eq_2692 * r10_6 = rdi->ptr0228;
	r10_6->qw0030 = 0x00;
	r10_6->qw0018 = 0x00;
	r10_6->ptr0010 = &r10_6->qw0058 + 2;
	r10_6->t0020.u0 = 0;
	r10_6->qw0058 = rdi->qw0190 + 0x01;
	r10_6->dw0008 = 0x00;
	r10_6->qw0000 = ~0x05F5E0FF;
	r10_6->qw0050 = 0x00;
	struct Eq_2733 * rdx_135 = rdi->ptr0238;
	struct Eq_2733 * rsi_20 = rdi->ptr0240;
	if (rdx_135 != rsi_20)
	{
		up64 r9_24 = rsi_20 - 64 - rdx_135;
		uint64 rcx_33 = (uint64) (((word32) r9_24 >> 0x06) + 0x01);
		if ((rcx_33 & 0x03) != 0x00)
		{
			ui64 rcx_39 = -(rcx_33 & 0x03);
			do
			{
				if (rdx_135->dw0018 != ~0x00)
					rdx_135->dw0018 = 0x01;
				++rdx_135;
				++rcx_39;
			} while (rcx_39 != 0x00);
		}
		if (r9_24 >= 0xC0)
		{
			do
			{
				if (rdx_135->dw0018 != ~0x00)
					rdx_135->dw0018 = 0x01;
				if (rdx_135->dw0058 != ~0x00)
					rdx_135->dw0058 = 0x01;
				if (rdx_135->dw0098 != ~0x00)
					rdx_135->dw0098 = 0x01;
				if (rdx_135->dw00D8 != ~0x00)
					rdx_135->dw00D8 = 0x01;
				rdx_135 += 4;
			} while (rsi_20 != rdx_135);
		}
	}
	if (&r10_6->qw0058 + 2 == rdi->ptr0230)
	{
		r10_6->t0020.u1 = 0x00;
		r10_6->qw0090 = 0x00;
	}
}

// 0000000000402340: Register uint64 write_circulations(Register Eq_61 rsi, Register (ptr64 Eq_187) rdi)
// Called from:
//      main
uint64 write_circulations(Eq_61 rsi, struct Eq_187 * rdi)
{
	uint64 rbp_27 = *((word64) rsi + 440);
	union Eq_239 * r12_28 = *((word64) rsi + 576);
	FILE * rax_32 = fopen(rdi, "w");
	uint64 r14_145 = ~0x00;
	if (rax_32 != null)
	{
		refresh_neighbour_lists(rsi);
		struct Eq_2848 * r13_134 = *((word64) *((word64) rsi + 552) + (*((word64) rsi + 400) * 0x68 + 56));
		if (r13_134 != null)
		{
			struct Eq_2848 * r12_56 = r12_28 - (rbp_27 << 0x06);
			do
			{
				if (r13_134->qw0030 != 0x00)
				{
					fwrite(&g_v40301F, 0x03, 0x01, rax_32);
					struct Eq_2848 * rbp_120 = r13_134;
l00000000004023CA:
					if (rbp_120 >= r12_56)
						fwrite(&g_v403023, 0x04, 0x01, rax_32);
					fprintf(rax_32, "%d\n", 0x00 - (rbp_120->ptr0010)->dw0060);
					struct Eq_2848 * rax_105;
					for (rax_105 = rbp_120->ptr0010->a0038[*((word64) rsi + 408)].ptr0000; rax_105 != null; rax_105 = rax_105->ptr0020)
					{
						if (rax_105->qw0030 != 0x00)
						{
							rbp_120 = null;
							if (rax_105->ptr0010->dw0060 != 0x00)
								rbp_120 = rax_105;
							if (rbp_120 == null)
								goto l0000000000402450;
							goto l00000000004023CA;
						}
					}
					fclose(rax_32);
					return r14_145;
				}
l0000000000402450:
				r13_134 = r13_134->ptr0020;
			} while (r13_134 != null);
		}
		fclose(rax_32);
		r14_145 = 0x00;
	}
	return r14_145;
}

// 0000000000402490: void update_tree(Register Eq_863 rcx, Register Eq_863 rdx, Register word32 esi, Register Eq_2946 rdi, Register (ptr64 Eq_2947) r8, Register (ptr64 Eq_2947) r9, Stack (ptr64 Eq_2947) qwArg08, Stack (ptr64 Eq_2947) qwArg10, Stack (ptr64 Eq_2947) qwArg18, Stack (ptr64 Eq_2952) qwArg20, Stack int64 qwArg28, Stack Eq_863 qwArg30)
// Called from:
//      primal_net_simplex
void update_tree(Eq_863 rcx, Eq_863 rdx, word32 esi, Eq_2946 rdi, struct Eq_2947 * r8, struct Eq_2947 * r9, struct Eq_2947 * qwArg08, struct Eq_2947 * qwArg10, struct Eq_2947 * qwArg18, struct Eq_2952 * qwArg20, int64 qwArg28, Eq_863 qwArg30)
{
	word64 rsi;
	word32 esi = (word32) rsi;
	int64 r11_351;
	struct Eq_2952 * r12_186 = qwArg20;
	struct Eq_2947 * rax_24 = qwArg20->ptr0008;
	if (qwArg28 < 0x00 && rax_24 == r9 || qwArg28 > 0x00 && rax_24 == r8)
	{
		r11_351 = -qwArg28;
		if (r11_351 < 0x00)
			r11_351 = qwArg28;
	}
	else
	{
		int64 r11_42 = -qwArg28;
		if (r11_42 < 0x00)
			r11_42 = qwArg28;
		r11_351 = -r11_42;
	}
	struct Eq_2947 * r13_224 = qwArg10;
	struct Eq_2947 * rax_346 = qwArg08;
l00000000004024E3:
	do
	{
		rax_346->qw0000 += r11_351;
		struct Eq_2947 * rbx_350 = rax_346;
		rax_346 = rax_346->ptr0010;
	} while (rax_346 != null);
	for (; rbx_350 != qwArg08; rbx_350 = rbx_350->ptr0018)
	{
		rax_346 = rbx_350->ptr0020;
		if (rax_346 != null)
			goto l00000000004024E3;
	}
	int64 r11_87 = qwArg08->qw0058;
	if (r8 != qwArg10)
	{
		Eq_863 rax_95 = -rdx;
		int64 rbx_192 = r11_87;
		struct Eq_2947 * r10_101 = r9;
		do
		{
			r8 = r8->ptr0018;
			struct Eq_2947 * r14_106 = r8->ptr0020;
			if (r14_106 != null)
				r14_106->ptr0028 = r8->ptr0028;
			struct Eq_2947 * rbp_114 = r8->ptr0028;
			struct Eq_2947 ** rbp_119 = &rbp_114->ptr0020;
			if (rbp_114 == null)
				rbp_119 = &r8->ptr0010;
			*rbp_119 = (struct Eq_2947 **) r14_106;
			r8->ptr0018 = r10_101;
			struct Eq_2947 * rbp_131 = r10_101->ptr0010;
			r8->ptr0020 = rbp_131;
			if (rbp_131 != null)
				rbp_131->ptr0028 = r8;
			r10_101->ptr0010 = r8;
			r8->ptr0028 = null;
			Eq_2946 r15_147 = (uint64) (int8) (r8->dw0008 == 0x00);
			Eq_863 rbp_157 = rax_95;
			if (r15_147 == rdi)
				rbp_157 = rdx;
			word64 rbp_167 = rbp_157 + Mem140[r8 + 80:word64];
			struct Eq_2952 * r14_168 = r8->ptr0030;
			int64 r10_169 = r8->qw0058;
			r8->dw0008 = esi;
			r8->t0050 = rcx;
			r8->ptr0030 = r12_186;
			r8->qw0058 = rbx_192;
			rbx_192 = r11_87 - r10_169;
			esi = (word32) r15_147;
			rcx = rbp_167;
			r10_101 = r8;
			r12_186 = r14_168;
		} while (r8 != qwArg10);
	}
	if (rdx > qwArg30)
	{
		if (qwArg10 != qwArg18)
		{
			Eq_863 rax_250 = -rdx;
			do
			{
				r13_224->qw0058 -= r11_87;
				Eq_863 rcx_261 = rdx;
				if ((int64) r13_224->dw0008 == rdi)
					rcx_261 = rax_250;
				Mem269[r13_224 + 80:word64] = Mem256[r13_224 + 80:word64] + rcx_261;
				r13_224 = r13_224->ptr0018;
			} while (r13_224 != qwArg18);
		}
		if (r9 != qwArg18)
		{
			Eq_863 rax_291 = -rdx;
			word128 xmm0_296 = (word128) r11_87;
			do
			{
				Eq_863 xmm1_300 = r9->t0050;
				Eq_863 rcx_302 = rdx;
				if ((int64) r9->dw0008 != rdi)
					rcx_302 = rax_291;
				r9->t0050 = __padd<word64[2]>(__punpcklqdq<word128>((word128) rcx_302, xmm0_296), xmm1_300);
				r9 = r9->ptr0018;
			} while (r9 != qwArg18);
		}
	}
	else
	{
		for (; r13_224 != qwArg18; r13_224 = r13_224->ptr0018)
			r13_224->qw0058 -= r11_87;
		for (; r9 != qwArg18; r9 = r9->ptr0018)
			r9->qw0058 += r11_87;
	}
}

// 00000000004026A0: Register (ptr64 Eq_2947) primal_iminus(Register (ptr64 Eq_2947) rcx, Register (ptr64 Eq_2947) rdx, Register (ptr64 word64) rsi, Register (ptr64 Eq_3186) rdi, Register (ptr64 (ptr64 Eq_2947)) r8)
// Called from:
//      primal_net_simplex
struct Eq_2947 * primal_iminus(struct Eq_2947 * rcx, struct Eq_2947 * rdx, word64 * rsi, struct Eq_3186 * rdi, struct Eq_2947 ** r8)
{
	struct Eq_2947 * rax_108 = null;
	if (rdx != rcx)
	{
		struct Eq_2947 * r9_10 = rdx;
		rdx = rcx;
		do
		{
			if (r9_10->qw0058 >= rdx->qw0058)
			{
				Eq_863 rcx_20;
				if (rdx->dw0008 != 0x00)
				{
					if (rdx->ptr0018->ptr0018 == null)
						goto l000000000040270F;
					rcx_20 = 0x01 - rdx->t0050;
					if (rdi->t0000 >= rcx_20)
						goto l0000000000402702;
				}
				else
				{
					rcx_20 = rdx->t0050;
					if (rdi->t0000 >= rcx_20)
					{
l0000000000402702:
						rdi->t0000 = rcx_20;
						*rsi = 0x01;
						rax_108 = rdx;
					}
				}
l000000000040270F:
				rdx = rdx->ptr0018;
				if (r9_10 == rdx)
					break;
				continue;
			}
			Eq_863 rcx_55;
			if (r9_10->dw0008 != 0x00)
			{
				rcx_55 = r9_10->t0050;
				if (rdi->t0000 <= rcx_55)
					goto l0000000000402740;
				goto l0000000000402733;
			}
			if (r9_10->ptr0018->ptr0018 != null)
			{
				rcx_55 = 0x01 - r9_10->t0050;
				if (rdi->t0000 > rcx_55)
				{
l0000000000402733:
					rdi->t0000 = rcx_55;
					*rsi = 0x00;
					rax_108 = r9_10;
				}
			}
l0000000000402740:
			r9_10 = r9_10->ptr0018;
		} while (r9_10 != rdx);
	}
	*r8 = (struct Eq_2947 **) rdx;
	return rax_108;
}

// 0000000000402760: void primal_update_flow(Register (ptr64 Eq_2947) rdx, Register (ptr64 Eq_2947) rsi, Register (ptr64 Eq_2947) rdi)
// Called from:
//      primal_net_simplex
void primal_update_flow(struct Eq_2947 * rdx, struct Eq_2947 * rsi, struct Eq_2947 * rdi)
{
	for (; rdi != rdx; rdi = rdi->ptr0018)
		rdi->t0050.u1 = (uint64) (int8) (rdi->dw0008 == 0x00);
	for (; rsi != rdx; rsi = rsi->ptr0018)
		rsi->t0050.u1 = (uint64) (int8) (rsi->dw0008 != 0x00);
}

// 00000000004027B0: void primal_net_simplex(Register (ptr64 Eq_108) rdi)
// Called from:
//      global_opt
void primal_net_simplex(struct Eq_108 * rdi)
{
	Eq_3315 tLoc60;
	Eq_3316 tLoc58;
	Eq_3317 tLoc50;
	Eq_3318 tLoc38;
	word64 rdi_26 = rdi->qw01A8;
	struct Eq_919 * rsi_27 = rdi->ptr0238;
	struct Eq_919 * r12_28 = rdi->ptr0240;
	while (true)
	{
		struct Eq_2952 * rax_41 = primal_bea_mpp(&tLoc60, r12_28, rsi_27, rdi_26);
		if (rax_41 == null)
			break;
		++rdi->qw0258;
		struct Eq_2947 ** rcx_121 = &rax_41->ptr0008;
		struct Eq_2947 ** rdx_123 = (char *) &rax_41->ptr0008 + 8;
		if (tLoc60 > 0x00)
		{
			rdx_123 = &rax_41->ptr0008;
			rcx_121 = (struct Eq_2947 **) ((char *) &rax_41->ptr0008 + 8);
		}
		struct Eq_2947 * r14_129 = *rcx_121;
		struct Eq_2947 * rbp_131 = *rdx_123;
		tLoc58 = (Eq_3316) 0x01;
		struct Eq_2947 * rax_139 = primal_iminus(rbp_131, r14_129, &tLoc38, &tLoc58, &tLoc50);
		if (rax_139 != null)
		{
			int64 rcx_177 = tLoc38;
			struct Eq_2947 * r9_182 = r14_129;
			if (rcx_177 == 0x00)
				r9_182 = rbp_131;
			Eq_2946 rdi_260 = (uint64) (int8) (rcx_177 == 0x00);
			if (rcx_177 == 0x00)
				rbp_131 = r14_129;
			Eq_863 rdx_209 = tLoc58.t0000;
			struct Eq_3455 * r14_193 = rax_139->ptr0030;
			uint32 ebx_277 = (uint32) (int8) (rcx_177 == (int64) rax_139->dw0008) + 0x01;
			int64 r10_208 = tLoc60;
			Eq_863 rcx_212 = 0x01 - rdx_209;
			if (r10_208 <= 0x00)
				rcx_212 = rdx_209;
			update_tree(rcx_212, rdx_209, (word32) (rax_41->ptr0008 == rbp_131), rdi_260, rbp_131, r9_182, rax_139, rax_139->ptr0018, tLoc50, rax_41, r10_208, rdi->t0200);
			rax_41->dw0018 = 0x00;
			r14_193->dw0018 = ebx_277;
			int64 rsi_280 = rdi->qw0258;
			word64 rax_286 = SLICE((rsi_280 - 1) *s128 ~0x5C28F5C28F5C28F4, word64, 64) + rsi_280;
			if (rsi_280 - 1 == ((rax_286 + ~0x00 >> 0x07) + (rax_286 + ~0x00 >>u 0x3F)) *s 200)
				rdi->qw0268 += refresh_potential(rdi);
		}
		else
		{
			++rdi->qw0260;
			rax_41->dw0018 = 0x02 - (uint32) ((int8) (rax_41->dw0018 == 0x02));
			if (tLoc58 != 0x00)
				primal_update_flow(tLoc50, rbp_131, r14_129);
		}
	}
	rdi->qw0268 += refresh_potential(rdi);
	primal_feasible(rdi);
	dual_feasible(rdi);
}

// 00000000004029B0: void bea_is_dual_infeasible(Register int64 rsi)
void bea_is_dual_infeasible(int64 rsi)
{
	if (rsi < 0x00)
		;
}

// 00000000004029D0: void sort_basket(Register Eq_3541 rsi, Register Eq_3541 rdi)
// Called from:
//      sort_basket
//      primal_bea_mpp
void sort_basket(Eq_3541 rsi, Eq_3541 rdi)
{
	do
	{
		word64 rax_24 = rdi + rsi;
		int64 r9_34 = g_a4050B0[(word64) rax_24 + (rax_24 >> 0x3F) & 0x3FFFFFFFFFFFFFFE].ptr0000->qw0010;
		Eq_3541 r8_35 = rsi;
		Eq_3541 rax_36 = rdi;
		do
		{
			Eq_3545 r10_40 = (word64) rax_36 - 1;
			do
			{
				struct Eq_3543 * rdx_44 = g_a4050B8[r10_210 * 0x08 /64 96];
				r10_40 = (word64) r10_210 + 1;
				r10_210 = r10_40;
			} while (rdx_44->qw0010 > r9_34);
			Eq_3545 rsi_53 = (word64) r8_35 + 1;
			do
			{
				struct Eq_3561 * rbx_57 = *((char *) g_a4050A8 + rsi_211 * 0x08);
				rsi_53 = rsi_211 - 1;
				rsi_211 = rsi_53;
			} while (r9_34 > rbx_57->qw0010);
			if (r10_40 < rsi_53)
			{
				g_a4050B8[r10_210 * 0x08 /64 96] = (struct Eq_3855) rbx_57;
				*((char *) g_a4050A8 + rsi_211 * 0x08) = (struct Eq_3561 **) rdx_44;
			}
			Eq_3574 rax_78 = (uint64) (int8) (r10_40 <= rsi_53);
			r8_35 = rsi_53 - rax_78;
			rax_36 = rax_78 + r10_40;
		} while (rax_36 <= r8_35);
		Eq_3592 r12_89 = (uint64) (int8) (r10_40 <= rsi_53);
		Eq_3541 rsi_90 = rsi_53 - r12_89;
		word64 r12_91 = r12_89 + r10_40;
		if (rsi_90 > rdi)
			sort_basket(rsi_90, rdi_119);
		if (r12_91 >= rsi)
			return;
		rdi = r12_91;
	} while (r12_91 < 0x33);
}

// 0000000000402AD0: Register uint64 primal_bea_mpp(Register (ptr64 word64) rcx, Register (ptr64 Eq_919) rdx, Register (ptr64 Eq_919) rsi, Register word64 rdi)
// Called from:
//      primal_net_simplex
uint64 primal_bea_mpp(word64 * rcx, struct Eq_919 * rdx, struct Eq_919 * rsi, word64 rdi)
{
	Eq_3541 r15_118;
	uint64 r10_120;
	uint64 r9_111;
	if (g_b405BA8 != 0x00)
	{
		Eq_3541 rdx_124 = basket_size;
		if (rdx_124 < 0x02)
			r15_118.u1 = 0x00;
		else
		{
			Eq_3541 rdi_128 = 0x02;
			r15_118.u1 = 0x00;
			do
			{
				struct Eq_3870 * rcx_137 = *g_a4050B0[rdi_744 *64 2].ptr0000;
				int64 rbx_142 = rcx_137->qw0000 - *rcx_137->ptr0008 + *rcx_137->ptr0010;
				if (rbx_142 >= 0x00)
				{
					if (rbx_142 != 0x00 && rcx_137->dw0018 == 0x02)
						goto l0000000000402C8B;
				}
				else if (rcx_137->dw0018 == 0x01)
				{
l0000000000402C8B:
					struct Eq_3887 * rbp_155 = g_a4050B8[r15_118 * 0x08 /64 96];
					rbp_155->ptr0000 = rcx_137;
					rbp_155->qw0008 = rbx_142;
					r15_118 = (word64) r15_118 + 1;
					int64 rcx_163 = -rbx_142;
					if (rcx_163 < 0x00)
						rcx_163 = rbx_142;
					rbp_155->qw0010 = rcx_163;
				}
				if (rdi_744 > 0x31)
					break;
				rdi_128 = (word64) rdi_744 + 1;
				rdi_744 = rdi_128;
			} while (rdi_744 < rdx_124);
		}
		basket_size = r15_118;
		r10_120 = group_pos;
		r9_111 = nr_group;
	}
	else
	{
		Eq_863 xmm5_27 = g_t403160;
		Eq_3633 xmm1_29 = g_t403170;
		word128 xmm2_33 = __pshuf<Eq_4178[4]>(405BB0, 405BB0, 0x44);
		struct Eq_3646 * rax_28 = (struct Eq_3646 *) ~0x0ADF;
		Eq_863 xmm8_34 = g_t403180;
		Eq_863 xmm9_35 = g_t403190;
		Eq_863 xmm10_36 = g_t4031A0;
		Eq_863 xmm11_37 = g_t4031B0;
		Eq_863 xmm7_38 = g_t4031C0;
		Eq_863 xmm3_39 = g_t4031D0;
		do
		{
			Eq_863 xmm4_60 = __padd<word64[2]>(__psll<word64[2]>(__pmulu<uint32[4],uint64[2]>(__psrl<word64[2]>(xmm5_27, 0x20), xmm1_29), 0x20), __padd<word64[2]>(__pmulu<uint32[4],uint64[2]>(xmm5_27, xmm1_29), xmm2_33));
			Eq_863 xmm0_65 = __padd<word64[2]>(xmm4_60, xmm8_34);
			rax_28->ow405B98 = (word128) xmm4_60;
			rax_28->ow405BA8 = (word128) xmm0_65;
			Eq_863 xmm0_73 = __padd<word64[2]>(xmm4_60, xmm9_35);
			Eq_863 xmm6_78 = __padd<word64[2]>(xmm4_60, xmm10_36);
			rax_28->ow405BB8 = (word128) xmm0_73;
			rax_28->ow405BC8 = (word128) xmm6_78;
			Eq_863 xmm0_85 = __padd<word64[2]>(xmm4_60, xmm11_37);
			Eq_863 xmm4_89 = __padd<word64[2]>(xmm4_60, xmm7_38);
			rax_28->ow405BD8 = (word128) xmm0_85;
			rax_28->ow405BE8 = (word128) xmm4_89;
			xmm5_27 = __padd<word64[2]>(xmm5_27, xmm3_39);
			++rax_28;
		} while (rax_28 != null);
		g_qw405B98 = 4226152;
		Eq_3746 rdx_106 = SLICE((rdi + ~0x00) *s128 0x6D3A06D3A06D3A07, word64, 64);
		uint64 r9_110 = (rdx_106 >> 0x07) + (rdx_106 >> 0x3F);
		nr_group = r9_110 + 0x01;
		g_qw405BA0 = 0x00407C80;
		g_b405BA8 = 0x01;
		group_pos = 0x00;
		basket_size.u0 = 0x00;
		r9_111 = r9_110 + 0x01;
		r15_118.u1 = 0x00;
		r10_120 = 0x00;
	}
	int64 rdx_195 = r9_111 << 0x06;
	uint64 r12_202 = r10_120;
	do
	{
		struct Eq_919 * rbx_207;
		for (rbx_207 = rsi + (r12_202 << 0x06) /64 64; rbx_207 < rdx; rbx_207 += rdx_195 /64 64)
		{
			int32 ebp_215 = rbx_207->dw0018;
			if (ebp_215 > 0x00)
			{
				int64 rdi_222 = rbx_207->qw0000 - *rbx_207->ptr0008 + *rbx_207->ptr0010;
				if (rdi_222 >= 0x00)
				{
					if (rdi_222 != 0x00 && ebp_215 == 0x02)
						goto l0000000000402D45;
				}
				else if (ebp_215 == 0x01)
				{
l0000000000402D45:
					struct Eq_3815 * rax_235 = g_a4050B8[r15_118 * 0x08 /64 96];
					r15_118 = (word64) r15_118.u1 + 1;
					basket_size = r15_118;
					rax_235->ptr0000 = rbx_207;
					rax_235->qw0008 = rdi_222;
					int64 rcx_244 = -rdi_222;
					if (rcx_244 < 0x00)
						rcx_244 = rdi_222;
					rax_235->qw0010 = rcx_244;
				}
			}
		}
		++r12_202;
		if (r12_202 == r9_111)
			r12_202 = 0x00;
	} while (r15_118 <= 0x31 && r12_202 != r10_120);
	uint64 rax_326;
	group_pos = r12_202;
	if (r15_118 != 0x00)
	{
		sort_basket(r15_118, 0x01);
		Eq_3855 rax_345 = g_a4050B8[0].ptr0000;
		*rcx = rax_345.ptr0000->qw0008;
		rax_326 = rax_345.ptr0000->qw0000;
	}
	else
	{
		g_b405BA8 = 0x00;
		*rcx = 0x00;
		rax_326 = 0x00;
	}
	return rax_326;
}

// 0000000000402DD0: void __libc_csu_init(Register word64 rdx, Register word64 rsi, Register word32 edi)
void __libc_csu_init(word64 rdx, word64 rsi, word32 edi)
{
	word64 rdi;
	word32 edi = (word32) rdi;
	_init();
	int64 rbp_31 = 4214264 - g_a404DF0;
	if (rbp_31 >> 0x03 != 0x00)
	{
		Eq_3952 rbx_45 = 0x00;
		do
		{
			(*((char *) g_a404DF0 + rbx_45 * 0x08))();
			rbx_45 = (word64) rbx_45.u1 + 1;
		} while (rbp_31 >> 0x03 != rbx_45);
	}
}

// 0000000000402E40: void __libc_csu_fini()
void __libc_csu_fini()
{
}

